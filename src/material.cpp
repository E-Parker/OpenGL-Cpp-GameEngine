#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <stb_image.h>

#include <cstring>
#include <iostream>

#include "createShader.h"
#include "hashTable.h"
#include "material.h"

static HashTable<Texture> TextureTable(512);

void TextureManager::InternalUploadTexture(Texture* texture, uint8_t* data, GLenum internalFormat, GLenum format) {
    glGenTextures(1, &texture->ID);
    glBindTexture(GL_TEXTURE_2D, texture->ID);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_MIN_FILTER, texture->filterType);
    glTextureParameteri(texture->ID, GL_TEXTURE_MAG_FILTER, texture->filterType);
    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, texture->width, texture->height, 0, format, GL_UNSIGNED_BYTE, data);
}

void TextureManager::InternalUploadTextureMimmap(Texture* texture, uint8_t* data, GLenum internalFormat, GLenum format) {
    glGenTextures(1, &texture->ID);
    glBindTexture(GL_TEXTURE_2D, texture->ID);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTextureParameteri(texture->ID, GL_TEXTURE_MAG_FILTER, texture->filterType);
    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, texture->width, texture->height, 0, format, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
}

void TextureManager::InternalDeleteTexture(Texture* texture) {
    if (--texture->references == 0) {
        if (texture->ID != GL_NONE) {
            glDeleteTextures(1, &(texture->ID));
        }
        texture->ID = GL_NONE;
        TextureTable.Delete(texture->alias);
    }
}

void TextureManager::InternalCreateTexture(Texture* texture, const bool isManaged, const char* alias, const GLenum internalFormat, const GLenum format, uint8_t* data, bool useMipmap) {
    /* Internal function for creating managed textures. */
    
    if (useMipmap) {
        TextureManager::InternalUploadTextureMimmap(texture, data, internalFormat, format);
    }
    else {
        TextureManager::InternalUploadTexture(texture, data, internalFormat, format);
    }

    texture->alias = TextureTable.Insert(alias, texture, isManaged);
    texture->references++;

}

void TextureManager::CreateRawTexture(const char* path, Texture* texture, GLenum internalFormat, GLenum format, bool flipVertical, bool flipHorizontal, bool useMipmaps, int filterType) {
    /* This function creates a new, unmanaged texture from the file path and the alias. if the texture already exists in memory, the returned value will be that one. */

    texture->filterType = filterType;
    
    stbi_set_flip_vertically_on_load(true);
    uint8_t* data = stbi_load(path, &texture->width, &texture->height, &texture->channels, 0);
    
    if (data == nullptr) {
        std::cout << "Error creating raw Texture from: \"" << path << "\". The texture will be discarded." << std::endl;
        return;
    }
    
    // Create the managed texture and upload the texture to the GPU.
    TextureManager::InternalCreateTexture(texture, true, path, internalFormat, format, data, useMipmaps);

    // Free the data generated by stb_image.
    stbi_image_free(data);

}

Texture* CreateTexture(const char* path, const char* alias, GLenum internalFormat, GLenum format, bool flipVertical, bool flipHorizontal, bool useMipmaps, int filterType) {
    /* This function creates a new texture from the file path and the alias. if the texture already exists in memory, the returned value will be that one.
    This will hopefully save delectably scrumptious graphics memory mmmhh. If an alias is not provided, the texture will use it's path as an alias. */

    char* aliasUsed;
    Texture* texture = nullptr;

    // If the alias is empty, use the path instead.
    if (!strcmp(alias, "")) { aliasUsed = const_cast<char*>(path); }
    else { aliasUsed = const_cast<char*>(alias); }

    // try to find the texture in the table.
    TextureTable.Find(aliasUsed, texture);

    // if the texture doesn't already exist, make a new one, and return that instead.
    if (texture != nullptr) {
        return nullptr;
    }
    
    texture = new Texture();
    texture->filterType = filterType;

    stbi_set_flip_vertically_on_load(true);
    uint8_t* data = stbi_load(path, &texture->width, &texture->height, &texture->channels, 0);

    if (data == nullptr) {
        std::cout << "Error creating Texture: \"" << aliasUsed << "\" From: \"" << path << "\". The texture will be discarded." << std::endl;
        return nullptr;
    }

    // Create the managed texture and upload the texture to the GPU.
    TextureManager::InternalCreateTexture(texture, false, aliasUsed, internalFormat, format, data, useMipmaps);

    // Free the data generated by stb_image.
    stbi_image_free(data);
    
    return texture;
}

void DeleteTexture(const char* alias) {
    /* This function manages deleting textures from the table. The texture will be deleted from graphics memory if it isn't referenced anywhere. */

    Texture* texture = nullptr;

    if (alias == nullptr) {
        return;
    }

    TextureTable.Find(alias, texture);

    if (texture == nullptr) {
        std::cout << "Error deleting Texture: \"" << alias << "\". No Texture with that name found. " << std::endl;
        return;
    }

    TextureManager::InternalDeleteTexture(texture);
}

void DereferenceTextures() {
    /* Call this function at the end of your program to ensure all tracked textures are properly cleaned up. */

    // Iterate through all the positions in the hash table.
    for (uint64_t i = 0; i < TextureTable.Size; i++) {
        
        // Check if there is a value stored here:
        if (TextureTable.Array[i].Key == nullptr) {
            continue;
        }
        
        Texture* texture = TextureTable.Array[i].Value;
        
        // Forcefully clear the memory for all textures marked as managed.
        if (TextureTable.Array[i].isManaged) {
            std::cout << "Texture Manager: Freeing texture, \"" << texture->alias << "\"." << std::endl;
            texture->references = 1;
            TextureManager::InternalDeleteTexture(texture);
        }
    }
}


Material::Material(const GLuint vertexProgram, const GLuint fragmentProgram, const uint16_t numberOfTextures, const GLenum cullFuncton, const GLenum depthFunction) {
    TexturesUsed = numberOfTextures;
    CullFunction = cullFuncton;
    DepthFunction = depthFunction;

    Textures = nullptr;
    
    if(TexturesUsed != 0) {
        Textures = new Texture*[TexturesUsed]{nullptr};
    }    Program = CreateProgram(vertexProgram, fragmentProgram);
}


Material::Material(const char* vertexProgramPath, const char* fragmentProgramPath, const uint16_t numberOfTextures, const GLenum cullFuncton, const GLenum depthFunction) {
    TexturesUsed = numberOfTextures;
    CullFunction = cullFuncton;
    DepthFunction = depthFunction;
    
    Textures = nullptr;
    
    if(TexturesUsed != 0) {
        Textures = new Texture*[TexturesUsed]{nullptr};
    }

    GLuint VertexProgram = GL_NONE;
    GLuint FragmentProgram = GL_NONE;

    // compile the shader programs
    CreateShader(&VertexProgram, GL_VERTEX_SHADER, vertexProgramPath);
    CreateShader(&FragmentProgram, GL_FRAGMENT_SHADER, fragmentProgramPath);
    Program = CreateProgram(VertexProgram, FragmentProgram);

    // clean up the now unneeded vertex and fragment programs.
    glDeleteShader(VertexProgram);
    glDeleteShader(FragmentProgram);
}


Material::~Material() {
    
    if (this == nullptr) {
        std::cout << "Error deleting Material: Material is null!!! " << std::endl;
        return;
    }

    if (TexturesUsed != 0) {

        for (int i = 0; i < TexturesUsed; i++) {
            if (Textures[i] != nullptr) {
                DeleteTexture(Textures[i]->alias);
            }
        }
        delete[] Textures;
    }

    glDeleteProgram(Program);
    Program = GL_NONE;
}


void Material::SetTexture(Texture* texture, uint16_t index){
    /* Manually set a texture from a texture pointer. AVOID USING!!!
    The textures set this way will be UNAMANGED and must be freed MANUALLY. */

    if (this == nullptr) {
        std::cout << "Error setting Material Texture: Material is null!!! " << std::endl;
        return;
    }
    
    if (index >= TexturesUsed) {
        std::cout << "Warning: Material Texture index out of range. Discarding texture. " << std::endl;
        return;
    }

    if (texture == nullptr) {
        std::cout << "Error setting Material Texture: Texture must not be null." << std::endl;
        return;
    }

    // If a texture already exists in that slot, try to delete it.
    if (Textures[index] != nullptr) {
        DeleteTexture(Textures[index]->alias);
    }

    Textures[index] = texture;
    texture->references++;
}

void Material::SetTexture(const char* alias, uint16_t index) {
    /* Set a material's texture at the given index, by the texture's alias. */

    if (this == nullptr) {
        std::cout << "Error setting Material Texture: Material is null!!! " << std::endl;
        return;
    }

    if (index >= TexturesUsed) {
        std::cout << "Warning: Material Texture index out of range. Discarding texture. " << std::endl;
        return;
    }

    Texture* texture = nullptr;
    TextureTable.Find(alias, texture);

    if (texture == nullptr) {
        std::cout << "Error setting Material Texture: \"" << alias << "\" At index: " << index << ". The texture could not be found." << std::endl;
        return;
    }

    // If a texture already exists in that slot, try to delete it.
    if (Textures[index] != nullptr) {
        DeleteTexture(Textures[index]->alias);
    }

    Textures[index] = texture;
    texture->references++;
}

void Material::BindMaterial() {
    /* Set up the material for rendering. */

    if (this == nullptr) {
        return;
    }

    // Set the shader program and get the uniform from the shader.
    glUseProgram(Program);
    glCullFace(CullFunction);
    glDepthFunc(DepthFunction);

    // Set the active texture for each texture in the material.
    for (uint16_t i = 0; i < TexturesUsed; i++) {
        if (Textures[i] != nullptr) {
            glActiveTexture(GL_TEXTURE0 + i);
            glBindTexture(GL_TEXTURE_2D, Textures[i]->ID);
        }
    }
}

